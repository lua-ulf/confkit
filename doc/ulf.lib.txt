================================================================================
ulf.lib : ulf.PackageSpec                                            *ulf.lib*
    ULF Standard Library

    Parents: ~
        |ulf.PackageSpec|

    Fields: ~
        {table}    (ulf.lib.table)
        {debug}    (ulf.lib.debug)
        {types}    (ulf.lib.types)
        {json}     (ulf.lib.json)
        {git}      (ulf.lib.git)
        {error}    (ulf.lib.error)
        {conf}     (ulf.lib.conf)
        {mt}       (ulf.lib.mt)
        {func}     (ulf.lib.func)
        {fs}       (ulf.lib.fs)
        {platform} (ulf.lib.platform)
        {string}   (ulf.lib.string)
        {Object}   (ulf.lib.obj)



================================================================================
ulf.lib.conf is a configuration management module designed for handling,
validating, and manipulating hierarchical configuration tables in Lua. It
enables structured configuration definitions with support for default values,
fallback logic, hooks, and typed fields.

Getting started with ulf.lib.conf:
  1. Define your configuration schema using `ulf.lib.conf.ctable`.
  2. Wrap it into a `ConfigBlock` to add validation, fallback, and hook
     support.
  3. Access fields within your config table, and rely on fallbacks and defaults
     where necessary.
  4. Use |ulf.lib.conf.schema| for schema-level configurations and
     |ulf.lib.conf.field| for individual field setup.
  5. Set up hooks and fallback logic as needed within `ConfigBlock`.

Below is an overview of the `ulf.lib.conf` architecture:
┌─────────────────────────────────────────────────────────┐
│ ┌──────────┐                                            │
│ │ Config   │      ┌────────────┐    ┌──────────┐        │
│ │ Block    │──▶   │ Field      │───▶│ Schema   │        │
│ │          │      │ Definitions│    │ Functions│        │
│ └──┬───────┘      └────────────┘    └──────────┘        │
│    │ Hooks +      ┌────────────┐     ▲                  │
│    │ Fallbacks    │ Validation │     └───────────┐      │
│    │ Applied      └──────▲─────┘                 │      │
│    ▼                     │                       │      │
│ ┌────────────────────┐   │       ┌────────────┐  │      │
│ │Default + Custom    │   │       │Field Access│◀─┘      │
│ │Fields, Descriptions│           │Utilities   │         │
│ └────────────────────┘           └────────────┘         │
│              ulf.lib.conf architecture                  │
└─────────────────────────────────────────────────────────┘

Main components of `ulf.lib.conf`:
  1 `ctable`: Defines hierarchical configuration tables with default values and descriptions.
  2 `ConfigBlock`: Manages configuration blocks that support field validation, fallbacks, and hooks.
  3 `schema`: Schema utilities for managing hierarchical table operations, such as nested lookups and table walking.
  4 `field`: Definitions of individual config fields with support for data types, descriptions, and default values.

More documentation on `ulf.lib.conf` can be found in:
https://github.com/ulf-project/ulf.lib

  :h ulf.lib.conf.ctable
  :h ulf.lib.conf.ConfigBlock
  :h ulf.lib.conf.schema
  :h ulf.lib.conf.field
  :h ulf.lib.conf.util

Example:
>lua

local ctable = require("ulf.lib.conf.schema").ctable

local severity_to_number = function(severity_name)
  local smap = {
    trace = 0,
    debug = 1,
    info = 2,
    warn = 3,
    error = 4,
    off = 5,
  }

  return smap[severity_name]
end

local Schema = ctable({
  config = ctable({

    global = ctable({

      severity = {
        "debug",
        [[Global severity level. This is a last resort value]],
        hook = function(v)
          return severity_to_number(v)
        end,
      },

      default_logger = {
        "default",
        [[
        This value defines the default logger when no logger is
        explicitely addressed.
        ]],
      },
    }, [[Global settings have presedence over local settings]]),

    formatter = ctable({
      line = ctable({

        custom_formatter = {
          nil,
          [[Option: a function which is called and returns a formatted line]],
          type = "function",
        },

        app_name_maxlen = {
          10,
          [[Length of the application name in an output line.]],
        },

        filename = {
          function(v) end,
          [[Returns the formatted filename]],
        },
      }, [[Settings for formatting line output.]]),
    }, [[Formatter settings]]),

    channels = ctable({
      stdout = ctable({
        name = "stdout",
        enabled = {
          true,
          [[enables or disables this channel]],
        },

        severity = {
          "debug",
          [[default channel severity level]],
          type = "number",
          fallback = "config.global.severity",
          hook = function(v)
            return severity_to_number(v)
          end,
        },
      }, [[Settings for the 'stdout' channel]]),

      fs = ctable({

        name = "fs",
        enabled = {
          true,
          [[enables or disables this channel]],
        },

        severity = {
          "debug",
          [[default channel severity level]],
        },
      }, [[Settings for the 'fs' channel]]),
    }, [[Channel settings]]),
  }, [[config root]]),
}, [[defaults node]])

<


ulf.lib.conf                                                    *ulf.lib.conf*




================================================================================
`ulf.lib.conf.field` is responsible for defining and managing configuration
fields within the `ulf.lib.conf` module.

This module encapsulates individual configuration fields, ensuring each field
is associated with its data type, optional default values, descriptions,
validation hooks, and fallbacks. By centralizing field responsibilities, this
module facilitates managing defaults, field validation, transformations, and
access logic, enabling concise control of each field's behavior.


Usage instructions:
  1. Define each configuration field using `ulf.lib.conf.field.cfield`.
  2. Use hooks and fallback configurations to customize field behaviors.
  3. Access validated and transformed field values through ConfigBlocks that
     leverage these field definitions.

Below is an overview of the `ulf.lib.conf.field` module:
┌─────────────────────────────────────────────────────────┐
│ ┌──────────┐                                            │
│ │ Config   │      ┌────────────┐    ┌──────────┐        │
│ │ Block    │──▶   │ Field      │───▶│ Schema   │        │
│ │          │      │ Definitions│    │ Functions│        │
│ └──┬───────┘      └────────────┘    └──────────┘        │
│    │ Hooks +      ┌────────────┐     ▲                  │
│    │ Fallbacks    │ Validation │     └───────────┐      │
│    │ Applied      └──────▲─────┘                 │      │
│    ▼                     │                       │      │
│ ┌────────────────────┐   │       ┌────────────┐  │      │
│ │Default + Custom    │   │       │Field Access│◀─┘      │
│ │Fields, Descriptions│           │Utilities   │         │
│ └────────────────────┘           └────────────┘         │
│              ulf.lib.conf.field module                  │
└─────────────────────────────────────────────────────────┘

Main components of `ulf.lib.conf.field`:
  1 `cfield`: Defines individual fields within configuration tables, specifying types, defaults, descriptions, and hooks.
  2 `validate`: Ensures each field conforms to the defined data type, hooks, and validation requirements.
  3 `is_cfield_spec`: Helper function that checks if a table follows the `cfield` specification format.
  4 `parse_cfield`: Parses and returns a configured `cfield` instance for easy field management.

Additional resources for `ulf.lib.conf.field`:
https://github.com/ulf-project/ulf.lib

  :h ulf.lib.conf.field
  :h ulf.lib.conf.ctable
  :h ulf.lib.conf.ConfigBlock
  :h ulf.lib.conf.schema
  :h ulf.lib.conf.util

Example: Examples: These examples start simple and introduce more features
progressively.

Basic Field Definition:
>lua
local field = require("ulf.lib.conf.field")

-- Define a field with a name and description:
local name_field = field.parse_cfield(
  "name",
  { "John Doe", "Name field" }
)
assert.equal("John Doe", name_field.value)
assert.equal("Name field", name_field.description)
<

Adding Data Type:
>lua
local age_field = field.parse_cfield(
  "age",
  { 42, "Age field", type = "number" }
)
assert.equal(42, age_field.value)
assert.equal("number", age_field.type)
<

Using Hooks to Transform Values:
>lua
local severity_to_number = function(severity_name)
  local smap = {
    trace = 0, debug = 1, info = 2, warn = 3, error = 4, off = 5
  }
  return smap[severity_name]
end

local severity_field = field.parse_cfield(
  "severity",
  { "debug", "Severity level", hook = severity_to_number }
)
assert.equal(1, severity_field.value)
</code>---

<

ulf.lib.conf.field                                        *ulf.lib.conf.field*



M.kinds()                                                          *M.kinds()*
    | 1 # Mandatory config field | 2 # Optional config field | 3 # Fallback
    config field | 10 # Non config field



M.cfield()                                                        *M.cfield()*
    Returns a config field


    Return: ~
        ulf.lib.conf.cfield


M.is_cfield_spec({t})                                     *M.is_cfield_spec()*
    comment


    Parameters: ~
        {t} (table)

    Return: ~
        boolean


M.parse_cfield()                                            *M.parse_cfield()*
    Parses a cfield table spec and returns an instance of cfield.

    Value is always the first list item. If the key 'value' is present then
    value is the value of this kv paire. If len is 1 then it is assumed that
    only a description is given and value can be optional set.





 vim:tw=78:ts=8:ft=help:norl:
